        -:    0:Source:/home/vstan/Documents/Dev/conix/src/list.c
        -:    0:Graph:/home/vstan/Documents/Dev/conix/cmake-build-debug-coverage/CMakeFiles/conix.dir/src/list.c.gcno
        -:    0:Data:/home/vstan/Documents/Dev/conix/cmake-build-debug-coverage/CMakeFiles/conix.dir/src/list.c.gcda
        -:    0:Runs:1
        -:    1:/* List - Simple linked list
        -:    2: * Copyright (C) 2020 Stan Vlad <vstan02@protonmail.com>
        -:    3: *
        -:    4: * This file is part of xCalc.
        -:    5: *
        -:    6: * xCalc is free software: you can redistribute it and/or modify
        -:    7: * it under the terms of the GNU General Public License as published by
        -:    8: * the Free Software Foundation, either version 3 of the License, or
        -:    9: * (at your option) any later version.
        -:   10: *
        -:   11: * This program is distributed in the hope that it will be useful,
        -:   12: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
        -:   14: * GNU General Public License for more details.
        -:   15: *
        -:   16: * You should have received a copy of the GNU General Public License
        -:   17: * along with this program. If not, see <https://www.gnu.org/licenses/>.
        -:   18: */
        -:   19:
        -:   20:#include <malloc.h>
        -:   21:
        -:   22:#include "list.h"
        -:   23:
        -:   24:typedef struct t_ListNode ListNode;
        -:   25:
        -:   26:struct t_List {
        -:   27:    ListNode* current;
        -:   28:    ListNode* head;
        -:   29:};
        -:   30:
        -:   31:struct t_ListNode {
        -:   32:    void* data;
        -:   33:    ListNode* next;
        -:   34:};
        -:   35:
        -:   36:static void list_node_destroy(ListNode*, void (*)(void*));
        -:   37:
        5:   38:extern List* list_create(void) {
        5:   39:    List *self = (List *) malloc(sizeof(List));
        5:   40:    self->current = self->head = NULL;
        5:   41:    return self;
        5:   41-block  0
        -:   42:}
        -:   43:
       11:   44:extern void list_destroy(List* self, void (*destroy)(void*)) {
       11:   45:    if (self) {
       11:   45-block  0
        5:   46:        list_node_destroy(self->current, destroy);
        5:   46-block  0
        5:   47:        free(self);
        -:   48:    }
       11:   49:}
        -:   50:
        4:   51:extern bool list_exists(List* self) {
        4:   52:    return (_Bool) self->current;
        4:   52-block  0
        -:   53:}
        -:   54:
        3:   55:extern void* list_get(List* self) {
       3*:   56:    return self->current ? self->current->data : NULL;
        3:   56-block  0
        3:   56-block  1
    %%%%%:   56-block  2
        3:   56-block  3
        -:   57:}
        -:   58:
        1:   59:extern void list_head(List* self) {
        1:   60:    self->current = self->head;
        1:   61:}
        -:   62:
        3:   63:extern void list_next(List* self) {
        3:   64:    if (self->current) {
        3:   64-block  0
        3:   65:        self->current = self->current->next;
        3:   65-block  0
        -:   66:    }
        3:   67:}
        -:   68:
        9:   69:extern void list_push(List* self, void* data) {
        9:   70:    ListNode* node = (ListNode*) malloc(sizeof(ListNode));
        9:   71:    node->data = data;
        9:   72:    node->next = self->head;
        9:   73:    self->head = node;
        9:   74:}
        -:   75:
        5:   76:static void list_node_destroy(ListNode* node, void (*destroy)(void*)) {
        5:   77:    if (node) {
        5:   77-block  0
    #####:   78:        destroy(node->data);
    %%%%%:   78-block  0
    #####:   79:        list_node_destroy(node->next, destroy);
    #####:   80:        free(node);
        -:   81:    }
        5:   82:}
